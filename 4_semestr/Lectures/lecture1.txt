
ООП
инкапсуляция [1] -> имплементация и интерфейс
наследование
полиморфизм

[1]

object = data + algorithm

struct shape
{
    char * name;
    int x, y, z;
    void print()
    {}
} shape;

shape_print();

struct shape;

shape_create(...);
shape_alloc(...)
shape_init
     _initZ
     _init_withColor

shape_destroy();

//-----------------------
project

list.c
list.h
test_sort2.c
----------
vector.c
vector.h
test_sort1.c
-------------
Makefile

#include <stdio.h>
#pragma once


struct list
{
    
};

list_create();
void list_destroy(list *);

$list.c
#include "list.h"

struct iter


Lecture 2

struct apple
{
    int x, y, z;
    int color;
    set_xy();
    set_data();
    draw();
};

struct warmapple
{
    struct apple a;
    worm worm[10];
}

//C++

struct warmapple 
    : apple
{
    \\--old-data(from apple)-\\
    draw();
}

a = apple_create();
apple_draw(a);

warm = warmaple_create();
wapple_draw(warm);


///////////////////

Apple a;
a.draw(); //apple::draw();
WApple w;
w.draw();

obj -> Apple -> warmapple
|
\---->> warm


apple       warm
    \      /
    warmapple          

struct warmapple
{
    struct apple a;
    struct warm w;    
}

apple_draw()
wormapple_draw(wormapple * p)
{
    apple * a = p;
    warm * w = &p->w;
    apple_draw(a); \
                     static tipization
    warm_draw(w);  /   
}

EX:

apple * a = ...;
warmapple = ...;
a->draw();
wa->draw();

NEW:
obj * a = apple_create();
apple * a = ...;
obj * wa = ...;

a->draw();
wa->draw();

obj * p = a | wa;
p->draw(); ???

C++ v ptr;
C
struct apple{ };
struct apple_m
{
    void (*draw)(apple * );
    void (*SRtxy)(apple *);

};

1)apple :      
-------------       
| m | data  |
-------------

2)apple :      
-------------       
| m | data  |
-------------
  \ ptr ---
   \--->| | <- таблица методов
        ---

1) a->draw(a); //struct without ptr (C)    2) a->m.draw(a); //struct with ptr(C++)

apple_draw(p)
{
    ad = (char*)p +  sizeof(apple.m);
    ad -> color;
    ad -> x;
}

---------------------
struct cont_methods
{
    next();
    prev();
    index();
    first();
    last();

}

cont:
cont_methods;
data(empty);

cont        ---------\
|                    |
container_methods   cont_methods
|                    |
V                    V
list_data            vector_data   


list.create()
{
    m->first = list_first;
    ////
    ////
}

vector.create()
{
    m->first = vector->first;
    ////
    ////
}

test_program

-Dcreate = list_create

list * l = list_create();
cont * p = vector_create();

l->get_index(l, 5);
p->add(p, new_elem);

list_add(p, new_elem)

1) iterator

d = get_first_data();
i = get_first();
i = get_next(i);
d = get_data(i);

typedef int ptr_t;


/////////////////////////
/////// LECTURE 3 ///////
/////////////////////////

Паттерны проги

Model. View. Controler

Model : моделирование игрового процесса
|-вызываем методы View
|
v
Veiw : отображение игрового процесса

Model
^
|- управление моделью
|
Controller : управление моделью

Игра Snake
Имеется прямоугольное поле, разбитое на клетки
координаты (0,0) внизу 
в некоторых клетках имеются кролики

голова: <, >, v, ^
Тело: ###

^   >
#   #
#   #
#   #

do it using list: 
head,           segment,  tail;
(x,y)           (x,y)
-----
direction

1)Напишем Makefile
Model, View1, View2, Controller1,_2,_3

View1: на текстовом терминале + управление цветом

View2: используя графику(2d графика)

Controller1: с помощью клавы (Human controller)

Controller2: AI (using algorithm)

Кто побеждает: smart controller
Кто проигравает: dumb controller

-----------------------------
Makefile:
model.h
model.cc(cpp)
//ModelPrivate.h

View.h  --------
| наследуются   |
v               v
tview.h         gview.h
rview.cc        gview.cc    


human.h
human.cc
-----------------------------
main.cc

Исполняемая прога Snake

No: about Makefile
CC -> CXX
CFLAGS -> CXXFLAGS

PROG = snake
OBJ = model.o main.o ...

all: $(PROG)

clean:

depend: $(CXX) -MM $(CXXFLAGS)
    *.cc
//or    
    $(OBJ.o=.cc) > .depend

-include .depend


$(PROG): $(OBJ)
    $(CXX) $(CXXFLAGS)
//    -o $(PROG)    $(OBJ)
//    -o $@         $^

go to main.cpp: #include

------------------------------------
#include "Name.h"

struct  
class   Name
{
private:
    int x,y,z;

public:
    void setColor(int data);
    Name();
    ~Name();
};

Name.cpp :
#include "Name.h"

void Name::setColor()
{
    //--//
}
Name::Name()
{
    //--//
}
Name::~Name()
{
    //--//
}


View.h------
|          |  
| наследуем|
v          v
TView    GView

class TView : publicView
{
    
}



main.cpp :

int main()
{
    View * v = get("text");
               get("gui"); // get-func of View.h
               View::get()

    text ? TView() : GView();

NO: when we will describe get: 
TView.h :
#include "View.h"
static View * obj;
static View * get();

? = new Tview();
? = new GView();
//it's a fabric class

fabir --> //singleton
            fabric

if (!obj)
{
    ...new...;
    obj = ...
} 
return obj;

}



